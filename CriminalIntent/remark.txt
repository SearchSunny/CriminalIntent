第7章
UI fragment与fragment管理器
本章，我们将学习开发一个名为CriminalIntent的应用。CriminalIntent应用可详细记录种种办
公室陋习，如随手将脏盘子丢在休息室水槽里，以及打印完自己的文件便径直走开，全然不顾打
印机里已经缺纸等。
通过CriminalIntent应用，陋习记录可包含标题、日期以及照片。也可在联系人中查找当事人，
然后通过Email、Twitter、Facebook或其他应用提出不满意见。记录并报告陋习后，有了好心情，
就可以继续完成工作或处理手头上的事情。
7.6 FragmentManager与fragment生命周期
	activity的FragmentManager负责调用队列中fragment的生命周期方法。添加fragment供
FragmentManager管理时，onAttach(Activity)、onCreate(Bundle)以及 onCreateView(...)方法会被调用。
	托管activity的onCreate(...)方法执行后，onActivityCreated(...)方法也会被调用。因
为我们正在向CrimeActivity.onCreate(...)方法中添加CrimeFragment，所以fragment被添
加后，该方法会被调用。
	向处于运行状态的activity中添加fragment时，以下fragment生命周期方法会被依次调用：
onAttach(Activity)、onCreate(Bundle)、 onCreateView(...)、onActivityCreated(Bundle)、
onStart()，以及onResume()方法。

第10章 使用fragment argument
10.1 从fragment 中启动activity
	从fragment中启动activity的实现方式，基本等同于从activity中启动另一activity的实现方式。
我们调用Fragment.startActivity(Intent)方法，该方法在后台会调用对应的Activity方法。
10.1.1 附加extra信息
	通过将mCrimeId值附加到Intent的extra上，我们可以告知CrimeFragment应显示的Crime
10.1.2 获取extra信息
	mCrimeId值现已安全存储到CrimeActivity的intent中。然而，要获取和使用extra信息的是CrimeFragment类。
	fragment有两种方式获取保存在activity的intent内的数据信息，即简单直接的方式和复杂灵活
的方式。在实现复杂但灵活的方式（该方式涉及到fragment argument的概念）前，我们首先试试
简单的方式。
简单起见，CrimeFragment直接使用getActivity()方法获取CrimeActivity的intent。返回
至CrimeFragment类，为extra添加key。然后，在onCreate(Bundle)方法中，得到CrimeActivity
的intent内的extra信息后，再使用它获取Crime对象。
	//简单的获取方式
	//UUID crimeId = (UUID)getActivity().getIntent().getSerializableExtra(EXTRA_CRIME_ID);
10.1.4 直接获取extra信息方式的缺点
	只需几行简单的代码，就可实现让fragment直接获取托管activity的intent。然而，这种方式是
以牺牲fragment的封装性为代价的。CrimeFragment不再是可复用的构建单元， 因为它总是需要
由某个具体activity托管着，该activity的Intent又定义了名为EXTRA_CRIME_ID的extra。
就CrimeFragment类来说，这看起来合情合理。但这也意味着，按照当前的编码实现，
CrimeFragment便再也无法用于任何其他的activity了。
一个比较好的做法是，将mCrimeId存储在CrimeFragment的某个地方，而不是将它保存在
CrimeActivity的私有空间里。这样，无需依赖于CrimeActivity的intent内指定extra的存在，
CrimeFragment就能获取自己所需的extra数据信息。fragment的“某个地方”实际就是它的
arguments bundle。
10.2 fragment argument
	每个fragment实例都可附带一个Bundle对象。该bundle包含有key-value对，我们可以如同附
加extra到Activity的intent中那样使用它们。一个key-value对即一个argument。
10.2.1 附加argument给fragment
	附加argument bundle给fragment，需调用Fragment.setArguments(Bundle)方法。注意，该
任务必须在fragment创建后、添加给activity前完成。
	Bundle args = new Bundle();
		args.putSerializable(EXTRA_CRIME_ID, crimeId);
		
		CrimeFragment fragment = new CrimeFragment();
		fragment.setArguments(args);
10.2.2 获取argument
	fragment在需要获取它的argument时，会先调用Fragment类的getArguments()方法，接着
再调用Bundle的限定类型的“get”方法，如getSerializable(...)方法。
	现在回到CrimeFragment.onCreate(...)方法中，调整代码，改为从fragment的argument
中获取UUID。
	//获取argument
	UUID crimeId = (UUID)getArguments().getSerializable(EXTRA_CRIME_ID);
	
第11章使用viewPager



第12章 对话框
AlertDialog视图封装在DialogFragment（Fragment的子类）实例中。不使
用DialogFragment，也可显示AlertDialog视图，但Android开发原则不推荐这种做法。使用
FragmentManager管理对话框，可使用更多配置选项来显示对话框。
另外，如果设备发生旋转，独立配置使用的AlertDialog会在旋转后消失，而配置封装在
fragment中的AlertDialog则不会有此问题。

二、同一activity托管的两个fragment，即CrimeFragment和DatePickerFragment间的数据传递;
2.1 传递数据给DatePickerFragment
要传递crime的记录日期给DatePickerFragment，需实现一个newInstance(Date)方法，
然后将Date作为argument附加给fragment。
2.2 返回数据给CrimeFragment
    为返回新日期给CrimeFragment，并实现模型层以及对应视图的更新，需将日期打包为extra
并附加到Intent上，然后调用CrimeFragment.onActivityResult(...)方法，并传入准备好
的Intent参数。
        对于activity的数据回传，我们调用startActivityForResult(...)方法，ActivityManager
负责跟踪记录父activity与子activity间的关系。当子activity回传数据后被销毁了，ActivityManager
知道接收返回数据的应为哪一个activity。
    1. 设置目标fragment
类似于activity间的关联，可将CrimeFragment设置成DatePickerFragment的目标fragment。
要建立这种关联，可调用以下Fragment方法
        目标fragment以及请求代码由FragmentManager负责跟踪记录，我们可调用fragment（设置
目标fragment的fragment）的getTargetFragment()和getTargetRequestCode()方法获取它们。
	2. 传递数据给目标fragment
    Activity.onActivityResult(...)方法是ActivityManager在子activity销毁后调用的父
activity方法。处理activity间的数据返回时，无需亲自动手，ActivityManager会自动调用Activity.
onActivityResult(...)方法。父activity接收到Activity.onActivityResult(...)方法的调用
后，其FragmentManager会调用对应fragment的Fragment.onActivityResult(...)方法

第16章 操作栏
16.1 选项菜单
16.1.1 在XML文件中定义选项菜单
16.1.2 创建选项菜单
	在代码中，Activity类提供了管理选项菜单的回调函数。在需要选项菜单时，Android会调
用Activity的onCreateOptionsMenu(Menu)方法。
	然而，按照CriminalIntent应用的设计，选项菜单相关的回调函数需在fragment而非activity里
实现。不用担心，Fragment也有自己的一套选项菜单回调函数
16.1.3 响应菜单项选择
	用户点击选项菜单中的菜单项时，fragment会收到onOptionsItemSelected(MenuItem)方
法的回调请求。该方法接受的传入参数是一个描述用户选择的MenuItem实例。
16.2 实现层级式导航
	目前为止，CriminalIntent应用主要依靠后退键在应用内导航。使用后退键的导航又称为临时
性导航，只能返回到上一次的用户界面。而Ancestral navigation，有时也称为层级式导航
（hierarchical navigation），可逐级向上在应用内导航。
16.2.1 启用应用图标的导航功能
	为启用应用图标向上导航按钮的功能，并在fragment视图上显示向左的图标，须调用以下方
法设置fragment的DisplayHomeAsUpEnabled属性：
	该方法来自于API 11级，因此需进行系统版本判断保证应用向下兼容，并使用@TargetApi(11)
注解阻止Android Lint报告兼容性问题。
	在CrimeFragment.onCreateView(...)中，调用setDisplayHomeAsUpEnabled(true)方法。
	调用setDisplayHomeAsUpEnabled(...)方法只是让应用图标转变为按钮，并显示
一个向左的图标而已。因此我们必须进行编码，实现点击按钮可向上逐级回退的功能
16.2.2 响应向上按钮
	为实现用户点击向上按钮返回至crime列表界面，我们可能会想到去创建一个intent，然后启
动CrimePagerActivity实例，如以下实现代码：
	FLAG_ACTIVITY_CLEAR_TOP指示Android在回退栈中寻找指定activity的存在实例，如图16-10
所示。如存在，则弹出栈中的所有其他activity，让启动的activity出现在栈顶，从而显示在屏幕上。
	然而，Android有更好的办法实现层级式导航：配合使用NavUtils便利类与manifest配置文件中的元数据。
	先来处理元数据。打开AndroidManifest.xml文件，在CrimePagerActivity声明中添加新的
meta-data属性，指定CrimePagerActivity的父类为CrimeListActivity。

	在CrimeFragment.onOptionsItemSelected(...)方法中，首先通过调用NavUtils.get-
ParentActivityName(Activity)方法，检查元数据中是否指定了父activity。如指定有父activity，
则调用navigateUpFromSameTask(Activity)方法，导航至父activity界面

	为什么使用NavUtils类要好于手动启动activity？首先，NavUtils类的实现代码既简洁又优
雅。其次，使用NavUtils类也可实现在manifest配置文件中统一管理activity间的关系。如果activity
间的关系发生改变，无需费力地去修改Java代码，我们只要简单修改配置文件中的一行代码即可。
16.3 可选菜单项
16.3.1 创建可选菜单XML文件
16.3.3 “还有个问题”
	这个问题就是经典的设备旋转问题。子标题显示后，旋转设备，这时因为用户界面的重新生
成，显示的子标题会消失。为解决此问题，需要一个实例变量记录子标题的显示状态，并且设置
保留CrimeListFragment，使得变量值在设备旋转后依然可用。
16.4 挑战练习：用于列表的空视图
	
第17章 	存储与加载本地文件
Android设备上的所有应用都有一个放置在沙盒中的文件目录。将文件保存在沙盒中可阻止
其他应用的访问、甚至是其他用户的私自窥探（当然，要是设备被root了的话，则用户可以随意
获取任何数据）。
每个应用的沙盒目录都是设备/data/data目录的子目录，且默认以应用包命名。
17.1 CriminalIntent 应用的数据存取
	CriminalIntent应用中，可保存的数据格式是JSON。我们将使用Context类的I/O方法写入或读取文件
17.1.1 保存crime数据到JSON文件
	在CriminalIntent应用中，CrimeLab类将负责触发数据的保存与加载，而创建和解析JSON数
据的工作则交由新的CriminalIntentJSONSerializer类以及当前的Crime类处理。
	
	什么时点保存数据合适呢？适用于移动应用的一个普遍规则是：尽可能频繁地保存数据，尤
其是用户数据修改行为发生时。既然修改crime记录后的数据更新都需CrimeLab类处理，那么最
靠谱的就是在该类中将数据保存到文件中。
如果数据保存过于频繁，应注意不要拖慢应用的运行，影响到用户的使用体验。我们的代码
中，数据只要有更新，都是重新将全部crime数据写入文件中。考虑到CriminalIntent应用的规模，
这样做不会太耗时。然而，对于超频繁数据保存的应用来说，应考虑采用某种方式只保存修改过
的数据，而不是每次都保存全部数据，比如说使用SQLite数据库等。第34章我们将学习如何在应
用中使用SQLite数据库。

17.1.2 从文件中读取crime数据
	现在我们来进行逆向操作，实现应用启动后，从文件中读取crime数据。
	在Crime.java中，添加一个接受JSONObject对象的构造方法
17.2 挑战练习：使用外部存储
	要将数据写入外部存储，需预先完成两件事。首先，检查外部存储是否可用，可借助
android.os.Environment类的一些方法和常量进行判断。其次，获得外部文件目录的句柄（可
在Context类中找到获取方法）。接下来的数据写入实现可参照CriminalIntentJSONSerializer
类的处理。
17.3 深入学习：Android 文件系统与Java I/O