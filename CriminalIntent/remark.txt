第7章
UI fragment与fragment管理器
本章，我们将学习开发一个名为CriminalIntent的应用。CriminalIntent应用可详细记录种种办
公室陋习，如随手将脏盘子丢在休息室水槽里，以及打印完自己的文件便径直走开，全然不顾打
印机里已经缺纸等。
通过CriminalIntent应用，陋习记录可包含标题、日期以及照片。也可在联系人中查找当事人，
然后通过Email、Twitter、Facebook或其他应用提出不满意见。记录并报告陋习后，有了好心情，
就可以继续完成工作或处理手头上的事情。
7.6 FragmentManager与fragment生命周期
	activity的FragmentManager负责调用队列中fragment的生命周期方法。添加fragment供
FragmentManager管理时，onAttach(Activity)、onCreate(Bundle)以及 onCreateView(...)方法会被调用。
	托管activity的onCreate(...)方法执行后，onActivityCreated(...)方法也会被调用。因
为我们正在向CrimeActivity.onCreate(...)方法中添加CrimeFragment，所以fragment被添
加后，该方法会被调用。
	向处于运行状态的activity中添加fragment时，以下fragment生命周期方法会被依次调用：
onAttach(Activity)、onCreate(Bundle)、 onCreateView(...)、onActivityCreated(Bundle)、
onStart()，以及onResume()方法。

第10章 使用fragment argument
10.1 从fragment 中启动activity
	从fragment中启动activity的实现方式，基本等同于从activity中启动另一activity的实现方式。
我们调用Fragment.startActivity(Intent)方法，该方法在后台会调用对应的Activity方法。
10.1.1 附加extra信息
	通过将mCrimeId值附加到Intent的extra上，我们可以告知CrimeFragment应显示的Crime
10.1.2 获取extra信息
	mCrimeId值现已安全存储到CrimeActivity的intent中。然而，要获取和使用extra信息的是CrimeFragment类。
	fragment有两种方式获取保存在activity的intent内的数据信息，即简单直接的方式和复杂灵活
的方式。在实现复杂但灵活的方式（该方式涉及到fragment argument的概念）前，我们首先试试
简单的方式。
简单起见，CrimeFragment直接使用getActivity()方法获取CrimeActivity的intent。返回
至CrimeFragment类，为extra添加key。然后，在onCreate(Bundle)方法中，得到CrimeActivity
的intent内的extra信息后，再使用它获取Crime对象。
	//简单的获取方式
	//UUID crimeId = (UUID)getActivity().getIntent().getSerializableExtra(EXTRA_CRIME_ID);
10.1.4 直接获取extra信息方式的缺点
	只需几行简单的代码，就可实现让fragment直接获取托管activity的intent。然而，这种方式是
以牺牲fragment的封装性为代价的。CrimeFragment不再是可复用的构建单元， 因为它总是需要
由某个具体activity托管着，该activity的Intent又定义了名为EXTRA_CRIME_ID的extra。
就CrimeFragment类来说，这看起来合情合理。但这也意味着，按照当前的编码实现，
CrimeFragment便再也无法用于任何其他的activity了。
一个比较好的做法是，将mCrimeId存储在CrimeFragment的某个地方，而不是将它保存在
CrimeActivity的私有空间里。这样，无需依赖于CrimeActivity的intent内指定extra的存在，
CrimeFragment就能获取自己所需的extra数据信息。fragment的“某个地方”实际就是它的
arguments bundle。
10.2 fragment argument
	每个fragment实例都可附带一个Bundle对象。该bundle包含有key-value对，我们可以如同附
加extra到Activity的intent中那样使用它们。一个key-value对即一个argument。
10.2.1 附加argument给fragment
	附加argument bundle给fragment，需调用Fragment.setArguments(Bundle)方法。注意，该
任务必须在fragment创建后、添加给activity前完成。
	Bundle args = new Bundle();
		args.putSerializable(EXTRA_CRIME_ID, crimeId);
		
		CrimeFragment fragment = new CrimeFragment();
		fragment.setArguments(args);
10.2.2 获取argument
	fragment在需要获取它的argument时，会先调用Fragment类的getArguments()方法，接着
再调用Bundle的限定类型的“get”方法，如getSerializable(...)方法。
	现在回到CrimeFragment.onCreate(...)方法中，调整代码，改为从fragment的argument
中获取UUID。
	//获取argument
	UUID crimeId = (UUID)getArguments().getSerializable(EXTRA_CRIME_ID);
	
第11章使用viewPager



第12章 对话框
AlertDialog视图封装在DialogFragment（Fragment的子类）实例中。不使
用DialogFragment，也可显示AlertDialog视图，但Android开发原则不推荐这种做法。使用
FragmentManager管理对话框，可使用更多配置选项来显示对话框。
另外，如果设备发生旋转，独立配置使用的AlertDialog会在旋转后消失，而配置封装在
fragment中的AlertDialog则不会有此问题。

二、同一activity托管的两个fragment，即CrimeFragment和DatePickerFragment间的数据传递;
2.1 传递数据给DatePickerFragment
要传递crime的记录日期给DatePickerFragment，需实现一个newInstance(Date)方法，
然后将Date作为argument附加给fragment。
2.2 返回数据给CrimeFragment
    为返回新日期给CrimeFragment，并实现模型层以及对应视图的更新，需将日期打包为extra
并附加到Intent上，然后调用CrimeFragment.onActivityResult(...)方法，并传入准备好
的Intent参数。
        对于activity的数据回传，我们调用startActivityForResult(...)方法，ActivityManager
负责跟踪记录父activity与子activity间的关系。当子activity回传数据后被销毁了，ActivityManager
知道接收返回数据的应为哪一个activity。
    1. 设置目标fragment
类似于activity间的关联，可将CrimeFragment设置成DatePickerFragment的目标fragment。
要建立这种关联，可调用以下Fragment方法
        目标fragment以及请求代码由FragmentManager负责跟踪记录，我们可调用fragment（设置
目标fragment的fragment）的getTargetFragment()和getTargetRequestCode()方法获取它们。
	2. 传递数据给目标fragment
    Activity.onActivityResult(...)方法是ActivityManager在子activity销毁后调用的父
activity方法。处理activity间的数据返回时，无需亲自动手，ActivityManager会自动调用Activity.
onActivityResult(...)方法。父activity接收到Activity.onActivityResult(...)方法的调用
后，其FragmentManager会调用对应fragment的Fragment.onActivityResult(...)方法

第16章 操作栏
16.1 选项菜单
16.1.1 在XML文件中定义选项菜单
16.1.2 创建选项菜单
	在代码中，Activity类提供了管理选项菜单的回调函数。在需要选项菜单时，Android会调
用Activity的onCreateOptionsMenu(Menu)方法。
	然而，按照CriminalIntent应用的设计，选项菜单相关的回调函数需在fragment而非activity里
实现。不用担心，Fragment也有自己的一套选项菜单回调函数
16.1.3 响应菜单项选择
	用户点击选项菜单中的菜单项时，fragment会收到onOptionsItemSelected(MenuItem)方
法的回调请求。该方法接受的传入参数是一个描述用户选择的MenuItem实例。
16.2 实现层级式导航
	目前为止，CriminalIntent应用主要依靠后退键在应用内导航。使用后退键的导航又称为临时
性导航，只能返回到上一次的用户界面。而Ancestral navigation，有时也称为层级式导航
（hierarchical navigation），可逐级向上在应用内导航。
16.2.1 启用应用图标的导航功能
	为启用应用图标向上导航按钮的功能，并在fragment视图上显示向左的图标，须调用以下方
法设置fragment的DisplayHomeAsUpEnabled属性：
	该方法来自于API 11级，因此需进行系统版本判断保证应用向下兼容，并使用@TargetApi(11)
注解阻止Android Lint报告兼容性问题。
	在CrimeFragment.onCreateView(...)中，调用setDisplayHomeAsUpEnabled(true)方法。
	调用setDisplayHomeAsUpEnabled(...)方法只是让应用图标转变为按钮，并显示
一个向左的图标而已。因此我们必须进行编码，实现点击按钮可向上逐级回退的功能
16.2.2 响应向上按钮
	为实现用户点击向上按钮返回至crime列表界面，我们可能会想到去创建一个intent，然后启
动CrimePagerActivity实例，如以下实现代码：
	FLAG_ACTIVITY_CLEAR_TOP指示Android在回退栈中寻找指定activity的存在实例，如图16-10
所示。如存在，则弹出栈中的所有其他activity，让启动的activity出现在栈顶，从而显示在屏幕上。
	然而，Android有更好的办法实现层级式导航：配合使用NavUtils便利类与manifest配置文件中的元数据。
	先来处理元数据。打开AndroidManifest.xml文件，在CrimePagerActivity声明中添加新的
meta-data属性，指定CrimePagerActivity的父类为CrimeListActivity。

	在CrimeFragment.onOptionsItemSelected(...)方法中，首先通过调用NavUtils.get-
ParentActivityName(Activity)方法，检查元数据中是否指定了父activity。如指定有父activity，
则调用navigateUpFromSameTask(Activity)方法，导航至父activity界面

	为什么使用NavUtils类要好于手动启动activity？首先，NavUtils类的实现代码既简洁又优
雅。其次，使用NavUtils类也可实现在manifest配置文件中统一管理activity间的关系。如果activity
间的关系发生改变，无需费力地去修改Java代码，我们只要简单修改配置文件中的一行代码即可。
16.3 可选菜单项
16.3.1 创建可选菜单XML文件
16.3.3 “还有个问题”
	这个问题就是经典的设备旋转问题。子标题显示后，旋转设备，这时因为用户界面的重新生
成，显示的子标题会消失。为解决此问题，需要一个实例变量记录子标题的显示状态，并且设置
保留CrimeListFragment，使得变量值在设备旋转后依然可用。
16.4 挑战练习：用于列表的空视图
	
第17章 	存储与加载本地文件
Android设备上的所有应用都有一个放置在沙盒中的文件目录。将文件保存在沙盒中可阻止
其他应用的访问、甚至是其他用户的私自窥探（当然，要是设备被root了的话，则用户可以随意
获取任何数据）。
每个应用的沙盒目录都是设备/data/data目录的子目录，且默认以应用包命名。
17.1 CriminalIntent 应用的数据存取
	CriminalIntent应用中，可保存的数据格式是JSON。我们将使用Context类的I/O方法写入或读取文件
17.1.1 保存crime数据到JSON文件
	在CriminalIntent应用中，CrimeLab类将负责触发数据的保存与加载，而创建和解析JSON数
据的工作则交由新的CriminalIntentJSONSerializer类以及当前的Crime类处理。
	
	什么时点保存数据合适呢？适用于移动应用的一个普遍规则是：尽可能频繁地保存数据，尤
其是用户数据修改行为发生时。既然修改crime记录后的数据更新都需CrimeLab类处理，那么最
靠谱的就是在该类中将数据保存到文件中。
如果数据保存过于频繁，应注意不要拖慢应用的运行，影响到用户的使用体验。我们的代码
中，数据只要有更新，都是重新将全部crime数据写入文件中。考虑到CriminalIntent应用的规模，
这样做不会太耗时。然而，对于超频繁数据保存的应用来说，应考虑采用某种方式只保存修改过
的数据，而不是每次都保存全部数据，比如说使用SQLite数据库等。第34章我们将学习如何在应
用中使用SQLite数据库。

17.1.2 从文件中读取crime数据
	现在我们来进行逆向操作，实现应用启动后，从文件中读取crime数据。
	在Crime.java中，添加一个接受JSONObject对象的构造方法
17.2 挑战练习：使用外部存储
	要将数据写入外部存储，需预先完成两件事。首先，检查外部存储是否可用，可借助
android.os.Environment类的一些方法和常量进行判断。其次，获得外部文件目录的句柄（可
在Context类中找到获取方法）。接下来的数据写入实现可参照CriminalIntentJSONSerializer
类的处理。
17.3 深入学习：Android 文件系统与Java I/O

第18章  上下文菜单与上下文操作模式
	本章，我们将为应用实现长按列表项删除crime记录的功能。删除一条crime记录是一种上下
文操作（contextual action），即它是与某个特定屏幕视图（单个列表项）而非整个屏幕相关联的。
	对于上下文操作，还是定义一种菜单资源，但我们必须实现两组不同的回调方法，一组用于上下文操作栏，一组用于浮动上下文菜单。
	（我们也许见过旧设备上运行的带有上下文操作栏的应用。通常来说，这些应用都是基于一
个名为ActionBarSherlock的第三方库开发的。该库通过模仿复制为旧系统设备实现了上下文操作
栏的功能。本章末尾我们将详细讨论ActionBarSherlock库的使用。）
18.1 定义上下文菜单资源

18.2 实施浮动上下文菜单
	首先，我们来创建浮动上下文菜单。Fragment的回调方法类似于第16章中用于选项菜单的
回调方法。要实例化生成一个上下文菜单，可使用以下方法：
	public void onCreateContextMenu(ContextMenu menu,....){}
	要响应用户的上下文菜单选择，可实现以下Fragment方法：
	public boolena onContextItemSelected(MenuItem item);

18.2.1 创建上下文菜单
	在CrimeListFragment.java中，实现onCreateContextMenu(...)方法
18.2.2 为上下文菜单登记视图
	默认情况下，长按视图不会触发上下文菜单的创建。要触发菜单的创建，必须调用以下
Fragment方法为浮动上下文菜单登记一个视图：
	public void registerFroContextMenu(View view);
	该方法需传入触发上下文菜单的视图。
	在CriminalIntent应用里，我们希望点击任意列表项，都能弹出上下文菜单。这岂不是意味着
需要逐个登记列表项视图吗？不用那么麻烦，直接登记ListView视图即可，然后它会自动登记
各个列表项视图。
18.2.3 响应菜单项选择
	Delete菜单项要可用，需要一个能够从模型层删除crime数据的方法。在CrimeLab.java中，新
增deleteCrime(Crime)方法。
18.3 实施上下文操作模式
	在新系统设备上，长按视图进入上下文操作模式是提供上下文操作的主流方式。屏幕进
入上下文操作模式时，上下文菜单中定义的菜单项会出现在覆盖着操作栏的上下文操作栏上，如图
18-3所示。相比浮动菜单，上下文操作栏不会遮挡屏幕，因此是更好的菜单展现方式。
18.3.1 实现列表视图的多选操作
	列表视图进入上下文操作模式时，可开启它的多选模式。多选模式下，上下文操作栏上的任
何操作都将同时应用于所有已选视图。
在CrimeListFragment.onCreateView(...) 方法中， 设置列表视图的选择模式为
CHOICE_MODE_MULTIPLE_MODAL
18.3.2 列表视图中的操作模式回调方法
	接下来，为ListView设置一个实现AbsListView.MultiChoiceModeListener接口的监听
器。该接口包含以下回调方法，视图在选中或撤销选中时会触发它
	public abstract void onItemCheckedStateChanged(ActionMode mode,......)
18.3.3 改变已激活视图的显示背景
	依据自身的不同状态，有时需要差别化地显示某个视图。CriminalIntent应用中，在列表项处
于激活状态时，我们希望能够改变其显示背景。视图处于激活状态，是指该视图已被用户标记为
关注处理对象。
	基于视图的状态，可使用state list drawable资源来改变其显示背景。state list drawable是一种
以XML定义的资源。该资源定义中，我们指定一个drawable（位图或彩图），并列出该drawable
对应的状态。（可查阅StateListDrawable参考手册页，了解更多视图相关状态。）
18.3.4 实现其他视图的上下文操作模式
	本章实现的上下文菜单栏可以完美地应用于ListView和GridView。（GridView是AdapterView
的子类，第26章中会用到它。）但如果视图既非ListView，也非GridView，要使用上下文操作栏又该如何处理呢？
	首先，设置一个实现View.OnLongClickListener接口的监听器。然后在监听器实现体内，
调用Activity.startActionMode(...)方法创建一个ActionMode实例。（前面已经看到，如果使
用的是MultiChoiceModeListener接口，ActionMode实例是自动创建的。）
18.4 兼容性问题：回退还是复制
	本章，我们已经用过一种叫做“优雅的回退”的兼容性策略。优雅的回退是指，应用在新系统
平台上运行时，可自动使用新平台的特色功能及代码，而在旧系统平台上运行时，则回退使用早期
的特色功能。从技术手段角度来说，这是通过在运行时检查SDK版本来实现的。
18.6 深入学习：ActionBarSherlock
	ActionBarSherlock（简称为ABS）旨在解决这种兼容性问题。ABS提供了一个向后兼容的操
作栏版本。此外，它还提供了一些支持类，可根据不同的版本系统，确定是使用原生还是向后兼
容版本的操作栏。可访问网站http://www.actionbarsherlock.com找到它。值得一提的是，它还提供
了Android最新主题的向后兼容版本（包含操作栏）。
	要下载ABS，请登陆网站http://www.actionbarsherlock.com/download.html，点击下载链接
18.7 挑战练习：使用ActionBarSherlock
18.7.1 CriminalIntent应用中ABS的基本整合
18.7.2 ABS的深度整合
18.7.3 ABS的完全整合